# Snakefile
include: "multi_file_workflow.smk"
from pathlib import Path
import json
import os

shell.executable("/bin/bash")

# ---- Paths ----
SCRIPTS_SRC = "script"                 # .cxx lives here
BUILD_DIR   = "build"
BIN_DIR     = f"{BUILD_DIR}/bin/scripts"
DATA_DIRS   = ["data/beamtests", "data/labtests"]
DUMP_DIR    = "dump"
LOG_DIR     = "log"

EOS_BASE = "/eos/experiment/alice/focal/tb2025_Oct_SPS/FoCalH/data"
EOS_DIRS = {
    "beamtests": f"{EOS_BASE}/beam",
    "labtests":  f"{EOS_BASE}/lab"
}
# ---- Load lxplus credentials (username/password in JSON) ----
CRED_FILE = "config/lxplus.json"
if not Path(CRED_FILE).exists():
    print(f"[WARN] Missing {CRED_FILE}. 'fetch_ch2g' rule will fail until you create it.")

def _creds():
    with open(CRED_FILE, "r") as fh:
        return json.load(fh)

EXES = ["100_RootConverter", "101_EventRecon", "102_EventMatch", "103_HitMap", "104_ADC_Analysis", "105_ToA_ToT_Starting", "106_ADC_Compare", "201_Waveform", "202_EventToA", "300_RootConverterX"]

# ---- Discover valid (dtype, run) pairs ----
pairs = []
for folder in DATA_DIRS:
    dtype = Path(folder).name  # "beamtests" or "labtests"
    for f in Path(folder).glob("Run*.ch2g"):
        if f.name.startswith('.') or not f.is_file():
            continue
        pairs.append({"dtype": dtype, "run": f.stem})

# Final analysis targets (only for discovered runs)
FINAL_TARGETS_HITMAP = [f"{DUMP_DIR}/103_HitMap/{p['dtype']}/{p['run']}.root" for p in pairs]
FINAL_TARGETS_ADC = [f"{DUMP_DIR}/104_ADC_Analysis/{p['dtype']}/{p['run']}.root" for p in pairs]
FINAL_TARGETS_ToAToTStart = [f"{DUMP_DIR}/105_ToA_ToT_Starting/{p['dtype']}/{p['run']}.root" for p in pairs]
FINAL_TARGETS_Waveform = [f"{DUMP_DIR}/201_Waveform/{p['dtype']}/{p['run']}.root" for p in pairs]
FINAL_TARGETS_EventToA = [f"{DUMP_DIR}/202_EventToA/{p['dtype']}/{p['run']}.root" for p in pairs]

FINAL_X_TARGETS_ROOT = [f"{DUMP_DIR}/300_RootConverterX/{p['dtype']}/{p['run']}.root" for p in pairs]
FINAL_X_TARGETS_MG = [f"{DUMP_DIR}/301_EventReconX/{p['dtype']}/{p['run']}_mg.root" for p in pairs]
FINAL_X_TARGETS_EventMatch = [f"{DUMP_DIR}/302_EventMatchX/{p['dtype']}/{p['run']}_em.root" for p in pairs]

FINAL_PEDESTAL_TARGETS = [f"{DUMP_DIR}/303_Pedestal/{p['dtype']}/{p['run']}.root" for p in pairs]
FINAL_RAWADC_TARGETS = [f"{DUMP_DIR}/304_RawADC/{p['dtype']}/{p['run']}.root" for p in pairs]
# Also require all executables be present
FINAL_EXES = [f"{BIN_DIR}/{name}" for name in EXES]

rule all:
    input:
        FINAL_EXES,
        FINAL_TARGETS_HITMAP,
        FINAL_TARGETS_ADC,
        FINAL_TARGETS_ToAToTStart,
        ALL_106_OUTPUTS,
        FINAL_TARGETS_Waveform,
        FINAL_TARGETS_EventToA,
        FINAL_X_TARGETS_EventMatch,
        FINAL_PEDESTAL_TARGETS,
        FINAL_RAWADC_TARGETS

# =========================
# Build system integration
# =========================
rule fetch_ch2g:
    output:
        local = "data/{dtype}/{run}.ch2g"
    params:
        remote = lambda wc: f"{EOS_DIRS[wc.dtype]}/{wc.run}.ch2g",
        cred   = "config/lxplus.json",
        user   = lambda wc: _creds().get("user", ""),
        host   = lambda wc: _creds().get("host", "lxplus.cern.ch"),
        realm  = "CERN.CH"
    log:
        "log/fetch/{dtype}/{run}.log"
    shell:
        r"""
        set -euo pipefail
        mkdir -p data/{wildcards.dtype} log/fetch/{wildcards.dtype}

        # Skip if already present and non-empty
        if [ -s "{output.local}" ]; then
          echo "[fetch] Exists: {output.local}" > "{log}"
          exit 0
        fi

        echo "[fetch] Remote: {params.user}@{params.host}:{params.remote}" > "{log}"

        have_ticket=false
        if klist -s 2>/dev/null; then
          have_ticket=true
          echo "[fetch] Kerberos ticket found." >> "{log}"
        else
          echo "[fetch] No Kerberos ticket. Attempting non-interactive kinit..." >> "{log}"
          if ! command -v jq >/dev/null 2>&1; then
            echo "[fetch][ERROR] jq not installed; cannot read {params.cred}" >> "{log}"
            exit 3
          fi
          PW=$(jq -r '.password' "{params.cred}")
          if [ -z "$PW" ] || [ "$PW" = "null" ]; then
            echo "[fetch][ERROR] No password in {params.cred}" >> "{log}"
            exit 4
          fi

          # Perform kinit non-interactively (no password printed)
          if printf '%s\n' "$PW" | kinit "{params.user}@{params.realm}" >> "{log}" 2>&1; then
            have_ticket=true
            echo "[fetch] kinit succeeded." >> "{log}"
          else
            echo "[fetch][ERROR] kinit failed. Check username/password or MFA policy." >> "{log}"
            have_ticket=false
          fi
        fi

        if [ "$have_ticket" = true ]; then
          # Use Kerberos-auth scp (no password prompt)
          scp -o GSSAPIAuthentication=yes \
              -o PreferredAuthentications=gssapi-with-mic \
              -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              {params.user}@{params.host}:"{params.remote}" "{output.local}" \
              >> "{log}" 2>&1 || true
        else
          echo "[fetch] No Kerberos available. Trying sshpass as last resort..." >> "{log}"
          if command -v sshpass >/dev/null 2>&1; then
            PW=$(jq -r '.password' "{params.cred}")
            sshpass -p "$PW" \
              scp -o PreferredAuthentications=password \
                  -o PubkeyAuthentication=no \
                  -o NumberOfPasswordPrompts=1 \
                  -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                  {params.user}@{params.host}:"{params.remote}" "{output.local}" \
              >> "{log}" 2>&1 || true
          else
            echo "[fetch][ERROR] sshpass not installed and Kerberos unavailable." >> "{log}"
          fi
        fi

        if [ ! -s "{output.local}" ]; then
          echo "[fetch][ERROR] Download failed." >> "{log}"
          exit 2
        fi
        echo "[fetch] OK -> {output.local}" >> "{log}"
        """


# Configure CMake once (stamp file)
rule cmake_configure:
    output:
        touch(f"{BUILD_DIR}/.cmake_configured")
    log:
        f"{LOG_DIR}/build/configure.log"
    shell:
        r"""
        mkdir -p {BUILD_DIR}
        mkdir -p {LOG_DIR}/build
        cmake -S . -B {BUILD_DIR} > {log} 2>&1
        """

# Build any executable target via CMake (single rule, wildcarded)
rule build_exe:
    input:
        cfg = rules.cmake_configure.output[0],
        src = lambda wc: f"{SCRIPTS_SRC}/{wc.name}.cxx"
    output:
        exe = f"{BIN_DIR}/{{name}}"
    log:
        f"{LOG_DIR}/build/{{name}}.log"
    shell:
        r"""
        mkdir -p {BIN_DIR}
        cmake --build {BUILD_DIR} --target {wildcards.name} -j > {log} 2>&1
        """

# =========================
# Data processing pipeline
# =========================

# Stage 100: RootConverter
rule RootConverter:
    input:
        exe   = f"{BIN_DIR}/100_RootConverter",
        ch2g  = lambda wc: f"data/{wc.dtype}/{wc.run}.ch2g"
    output:
        root  = f"{DUMP_DIR}/100_RootConverter/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/100_RootConverter/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/100_RootConverter/{wildcards.dtype}
        mkdir -p {LOG_DIR}/100_RootConverter/{wildcards.dtype}
        {input.exe} -i {input.ch2g} -o {output.root} > {log} 2>&1
        """

# Stage 101: EventRecon
rule EventRecon:
    input:
        exe     = f"{BIN_DIR}/101_EventRecon",
        root_in = f"{DUMP_DIR}/100_RootConverter/{{dtype}}/{{run}}.root"
    output:
        root_out = f"{DUMP_DIR}/101_EventRecon/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/101_EventRecon/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/101_EventRecon/{wildcards.dtype}
        mkdir -p {LOG_DIR}/101_EventRecon/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 102: EventMatch
rule EventMatch:
    input:
        exe     = f"{BIN_DIR}/102_EventMatch",
        root_in = f"{DUMP_DIR}/101_EventRecon/{{dtype}}/{{run}}.root"
    output:
        root_out = f"{DUMP_DIR}/102_EventMatch/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/102_EventMatch/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/102_EventMatch/{wildcards.dtype}
        mkdir -p {LOG_DIR}/102_EventMatch/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 103: HitMap
rule HitMap:
    input:
        exe     = f"{BIN_DIR}/103_HitMap",
        root_in = f"{DUMP_DIR}/302_EventMatchX/{{dtype}}/{{run}}_em.root"
    output:
        root_out = f"{DUMP_DIR}/103_HitMap/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/103_HitMap/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/103_HitMap/{wildcards.dtype}
        mkdir -p {LOG_DIR}/103_HitMap/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 104: ADC_Analysis
rule ADC_Analysis:
    input:
        exe     = f"{BIN_DIR}/104_ADC_Analysis",
        root_in = f"{DUMP_DIR}/302_EventMatchX/{{dtype}}/{{run}}_em.root"
    output:
        root_out = f"{DUMP_DIR}/104_ADC_Analysis/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/104_ADC_Analysis/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/104_ADC_Analysis/{wildcards.dtype}
        mkdir -p {LOG_DIR}/104_ADC_Analysis/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 105: ToA_ToT_Starting
rule ToA_ToT_Starting:
    input:
        exe     = f"{BIN_DIR}/105_ToA_ToT_Starting",
        root_in = f"{DUMP_DIR}/302_EventMatchX/{{dtype}}/{{run}}_em.root"
    output:
        root_out = f"{DUMP_DIR}/105_ToA_ToT_Starting/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/105_ToA_ToT_Starting/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/105_ToA_ToT_Starting/{wildcards.dtype}
        mkdir -p {LOG_DIR}/105_ToA_ToT_Starting/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 201: Waveform
rule Waveform:
    input:
        exe     = f"{BIN_DIR}/201_Waveform",
        root_in = f"{DUMP_DIR}/302_EventMatchX/{{dtype}}/{{run}}_em.root"
    output:
        root_out = f"{DUMP_DIR}/201_Waveform/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/201_Waveform/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/201_Waveform/{wildcards.dtype}
        mkdir -p {LOG_DIR}/201_Waveform/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 202: EventToA
rule EventToA:
    input:
        exe     = f"{BIN_DIR}/202_EventToA",
        root_in = f"{DUMP_DIR}/302_EventMatchX/{{dtype}}/{{run}}_em.root"
    output:
        root_out = f"{DUMP_DIR}/202_EventToA/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/202_EventToA/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/202_EventToA/{wildcards.dtype}
        mkdir -p {LOG_DIR}/202_EventToA/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 300: RootConverterX
rule RootConverterX:
    input:
        exe   = f"{BIN_DIR}/300_RootConverterX",
        ch2g  = lambda wc: f"data/{wc.dtype}/{wc.run}.ch2g"
    output:
        root  = f"{DUMP_DIR}/300_RootConverterX/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/300_RootConverterX/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/300_RootConverterX/{wildcards.dtype}
        mkdir -p {LOG_DIR}/300_RootConverterX/{wildcards.dtype}
        {input.exe} -i {input.ch2g} -o {output.root} > {log} 2>&1
        """

# Stage 301: EventReconX
rule EventReconX:
    input:
        exe     = f"{BIN_DIR}/301_EventReconX",
        root_in = f"{DUMP_DIR}/300_RootConverterX/{{dtype}}/{{run}}.root"
    output:
        root_out = f"{DUMP_DIR}/301_EventReconX/{{dtype}}/{{run}}_mg.root"
    log:
        f"{LOG_DIR}/301_EventReconX/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/301_EventReconX/{wildcards.dtype}
        mkdir -p {LOG_DIR}/301_EventReconX/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 302: EventMatchX
rule EventMatchX:
    input:
        exe     = f"{BIN_DIR}/302_EventMatchX",
        root_in = f"{DUMP_DIR}/301_EventReconX/{{dtype}}/{{run}}_mg.root"
    output:
        root_out = f"{DUMP_DIR}/302_EventMatchX/{{dtype}}/{{run}}_em.root"
    log:
        f"{LOG_DIR}/302_EventMatchX/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/302_EventMatchX/{wildcards.dtype}
        mkdir -p {LOG_DIR}/302_EventMatchX/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 303: Pedestal
rule Pedestal:
    input:
        exe     = f"{BIN_DIR}/303_Pedestal",
        root_in = f"{DUMP_DIR}/302_EventMatchX/{{dtype}}/{{run}}_em.root"
    output:
        root_out = f"{DUMP_DIR}/303_Pedestal/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/303_Pedestal/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/303_Pedestal/{wildcards.dtype}
        mkdir -p {LOG_DIR}/303_Pedestal/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """

# Stage 304: RawADC
rule RawADC:
    input:
        exe     = f"{BIN_DIR}/304_RawADC",
        root_in = f"{DUMP_DIR}/302_EventMatchX/{{dtype}}/{{run}}_em.root"
    output:
        root_out = f"{DUMP_DIR}/304_RawADC/{{dtype}}/{{run}}.root"
    log:
        f"{LOG_DIR}/304_RawADC/{{dtype}}/{{run}}.log"
    shell:
        r"""
        mkdir -p {DUMP_DIR}/304_RawADC
        mkdir -p {DUMP_DIR}/304_RawADC/{wildcards.dtype}
        mkdir -p {LOG_DIR}/304_RawADC
        mkdir -p {LOG_DIR}/304_RawADC/{wildcards.dtype}
        {input.exe} -f {input.root_in} -o {output.root_out} > {log} 2>&1
        """ 